#
# Copyright (C) 2025 Eeshvar Das (Erik Douglas Ward) (https://github.com/apm-essence-groove/apm-essence-groove-ci-cd)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

name: Full App Discovery, Docs & Deploy

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to run the workflow on (e.g., main, new-apps)'
        required: true
        default: 'main'
  push:
    branches:
      - main
      - cpp-apmw-3_9_0 # Or your current development branch
    paths:
      - '**'

jobs:
  # ... (find_apps, generate_docs_files, intelligent_ci, deploy_for_testing, prepare_deploy_matrix jobs remain the same) ...

  find_apps:
    runs-on: ubuntu-latest
    outputs:
      app_details_json: ${{ steps.scan.outputs.app_details_json }}
      force_apps_json_upload: ${{ steps.manage_workflow_state.outputs.force_apps_json_upload_for_generator }}
      workflow_state_json: ${{ steps.manage_workflow_state.outputs.workflow_state_output }}
    env:
      APP_BASE_DIRS: "homepage-app"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Read Workflow State for Artifact Logic
        id: manage_workflow_state
        run: |
          STATE_FILE=".github/workflow_state.json"
          DOWNLOAD_COUNT_KEY="apps_json_download_count"
          FORCE_UPLOAD_KEY="force_next_upload"
          DOWNLOAD_THRESHOLD_KEY="apps_json_download_threshold"
          CURRENT_STATE=$(jq '.' "$STATE_FILE" || echo '{}')
          echo "::debug::Current state (find_apps) read from file: $CURRENT_STATE"
          CURRENT_DOWNLOAD_COUNT=$(echo "$CURRENT_STATE" | jq -r ".${DOWNLOAD_COUNT_KEY} // 0")
          CURRENT_FORCE_FLAG=$(echo "$CURRENT_STATE" | jq -r ".${FORCE_UPLOAD_KEY} // false")
          DOWNLOAD_THRESHOLD=$(echo "$CURRENT_STATE" | jq -r ".${DOWNLOAD_THRESHOLD_KEY} // 0")
          echo "::debug::Initial state (find_apps) - Download Count: $CURRENT_DOWNLOAD_COUNT, Force Flag: $CURRENT_FORCE_FLAG, Threshold: $DOWNLOAD_THRESHOLD"
          FORCE_UPLOAD_FOR_GENERATOR="false"
          if [ "$DOWNLOAD_THRESHOLD" -eq 0 ]; then
            FORCE_UPLOAD_FOR_GENERATOR="true"
            echo "::notice::Download threshold is 0. Forcing apps.json upload for generate_docs_files."
          elif [ "$CURRENT_DOWNLOAD_COUNT" -ge "$DOWNLOAD_THRESHOLD" ] || [ "$CURRENT_FORCE_FLAG" = "true" ]; then
            FORCE_UPLOAD_FOR_GENERATOR="true"
            echo "::notice::Download count ($CURRENT_DOWNLOAD_COUNT) reached threshold ($DOWNLOAD_THRESHOLD) OR force flag was true. Signalling force apps.json upload for generate_docs_files."
          else
            echo "::notice::Download count: $CURRENT_DOWNLOAD_COUNT/$DOWNLOAD_THRESHOLD. No force upload this run (yet)."
          fi
          echo "force_apps_json_upload_for_generator=$FORCE_UPLOAD_FOR_GENERATOR" >> "$GITHUB_OUTPUT"
          COMPACT_STATE=$(echo "$CURRENT_STATE" | jq -c '.')
          echo "workflow_state_output=$COMPACT_STATE" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Scan for Apps and Collect Details
        id: scan
        run: |
          set -e
          APP_DETAILS_ARRAY=()
          echo "--- Starting App Scan ---"
          echo "Scanning for apps in base directories: $APP_BASE_DIRS"
          for BASE_DIR in $APP_BASE_DIRS; do
            if [ ! -d "$BASE_DIR" ]; then
              echo "::error::Base directory '$BASE_DIR' not found."
              continue
            fi
            FOUND_DIRS=$(find "$BASE_DIR" -type f -name "package.json" -exec dirname {} \;)
            for APP_DIR in $FOUND_DIRS; do
              PACKAGE_JSON_PATH="$APP_DIR/package.json"
              echo "--- Processing app directory: $APP_DIR ---"
              if [ ! -f "$PACKAGE_JSON_PATH" ]; then
                echo "::warning::package.json not found for ${APP_DIR}. Skipping."
                continue
              fi
              APP_NAME=$(jq -r '.name' "$PACKAGE_JSON_PATH" || echo "")
              HEROKU_APP_NAME=$(jq -r '.herokuAppName' "$PACKAGE_JSON_PATH" || echo "")
              DEPLOYED_URL=$(jq -r '.deployedUrl' "$PACKAGE_JSON_PATH" || echo "")
              if [ -z "$APP_NAME" ] || [ "$APP_NAME" == "null" ] || [ -z "$HEROKU_APP_NAME" ] || [ "$HEROKU_APP_NAME" == "null" ] || [ -z "$DEPLOYED_URL" ] || [ "$DEPLOYED_URL" == "null" ]; then
                echo "::warning::'name', 'herokuAppName', or 'deployedUrl' missing in ${PACKAGE_JSON_PATH}. Skipping."
                continue
              fi
              APP_FOLDER_NAME=$(basename "$APP_DIR")
              if [ "$APP_FOLDER_NAME" != "$APP_NAME" ]; then
                echo "::warning::Folder name ('${APP_FOLDER_NAME}') does NOT match 'name' in package.json ('${APP_NAME}')."
              fi
              APP_JSON_OBJ="{\"app_dir\":\"$APP_DIR\", \"name\":\"$APP_NAME\", \"herokuAppName\":\"$HEROKU_APP_NAME\", \"url\":\"$DEPLOYED_URL\"}"
              APP_DETAILS_ARRAY+=("$APP_JSON_OBJ")
            done
          done
          echo "--- App Scan Summary ---"
          if [ ${#APP_DETAILS_ARRAY[@]} -eq 0 ]; then
            echo "No valid applications found during scan."
            APP_DETAILS_JSON_OUTPUT="[]"
          else
            echo "Total valid applications found: ${#APP_DETAILS_ARRAY[@]}"
            APP_DETAILS_JSON_OUTPUT=$(printf "%s\n" "${APP_DETAILS_ARRAY[@]}" | jq -s -c .)
          fi
          echo "Final app_details_json output: $APP_DETAILS_JSON_OUTPUT"
          printf "app_details_json=%s\n" "$APP_DETAILS_JSON_OUTPUT" >> "$GITHUB_OUTPUT"
        shell: bash

  build_cpp_app:
    name: "Build C++ App and Commit Report"
    runs-on: ubuntu-latest
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Check for C++ Project"
        id: scan_cpp
        run: |
          CPP_PROJECT_DIR="homepage-app/unofficial-fan-videogame-baseball-club-main"
          if [ -d "$CPP_PROJECT_DIR" ] && [ -f "$CPP_PROJECT_DIR/CMakeLists.txt" ]; then
            echo "::notice::C++ project found in $CPP_PROJECT_DIR. Proceeding with C++ build."
            echo "project_found=true" >> "$GITHUB_OUTPUT"
            echo "project_dir=$CPP_PROJECT_DIR" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::No C++ project found in $CPP_PROJECT_DIR. Skipping build."
            echo "project_found=false" >> "$GITHUB_OUTPUT"
          fi

      - name: "Install C++ Build Tools"
        if: steps.scan_cpp.outputs.project_found == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake
        
      - name: "Determine Executable Name from CMake"
        id: find_exe
        if: steps.scan_cpp.outputs.project_found == 'true'
        working-directory: ${{ steps.scan_cpp.outputs.project_dir }}
        run: |
          EXE_NAME=$(grep -oP 'add_executable\(\s*\K[^)\s]+' CMakeLists.txt | head -n 1)
          if [ -z "$EXE_NAME" ]; then
            echo "::error::Could not determine executable name from add_executable() in CMakeLists.txt."
            exit 1
          fi
          echo "Found executable name: $EXE_NAME"
          echo "exe_name=$EXE_NAME" >> "$GITHUB_OUTPUT"

      - name: "Configure and Build with CMake"
        if: steps.scan_cpp.outputs.project_found == 'true'
        working-directory: ${{ steps.scan_cpp.outputs.project_dir }}
        run: |
          echo "--- Configuring C++ project with CMake ---"
          cmake -S . -B build
          echo "--- Building C++ project ---"
          cmake --build build

      - name: Run C++ Application to Generate Report
        id: run_cpp_app
        if: steps.scan_cpp.outputs.project_found == 'true' && steps.find_exe.outputs.exe_name
        working-directory: ${{ steps.scan_cpp.outputs.project_dir }}
        run: |
          ./build/${{ steps.find_exe.outputs.exe_name }}
        continue-on-error: true

      - name: "Check for Generated Report"
        id: check_report
        if: steps.run_cpp_app.outcome == 'success'
        working-directory: ${{ steps.scan_cpp.outputs.project_dir }}
        run: |
          # FIX: Look for the correct v3.9 report file
          REPORT_FILE="schedule_report_v3.9.md"
          if [ -f "$REPORT_FILE" ]; then
            echo "::notice::$REPORT_FILE was generated successfully."
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "report_name=$REPORT_FILE" >> "$GITHUB_OUTPUT"
          else
            echo "::warning::$REPORT_FILE was not found after running the C++ application."
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit and Push Schedule Report
        if: steps.check_report.outputs.exists == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          # FIX: Update commit message and file pattern for v3.9
          commit_message: "Bot: Add/Update C++ generated schedule report (v3.9.x) [skip ci]"
          file_pattern: "${{ steps.scan_cpp.outputs.project_dir }}/${{ steps.check_report.outputs.report_name }}"
          skip_dirty_check: true
          push_options: "--force"
  
  # ... (other jobs like prepare_deploy_matrix, deploy_all_apps, etc. would go here)

