#
# Copyright (C) 2025 Eeshvar Das (Erik Douglas Ward) (https://github.com/apm-essence-groove/apm-essence-groove-ci-cd)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

name: Full App Discovery, Docs & Deploy

#
# CONCEPT DEMONSTRATION: Naming the Workflow (1.2.1)
# ---------------------------------------------------
# The `name` key provides a clear, human-readable name for the workflow.
# This name is what appears in the GitHub Actions UI, making it easy to
# identify and distinguish from other workflows in the repository.
#

#
# CONCEPT DEMONSTRATION: The 'on' Event Trigger (1.2.2)
# ---------------------------------------------------
# The `on` key defines the event(s) that will trigger the workflow. This workflow
# demonstrates several types of triggers:
#
# - Webhook Event (`push`): The workflow runs automatically when a commit is
#   pushed to the repository.
#
# - Filtered Webhooks (`branches`, `paths`): The `push` event is filtered to
#   only run for commits on specific branches and when changes occur in any
#   file path (`**`).
#
# - Manual Event (`workflow_dispatch`): Allows the workflow to be triggered
#   manually from the GitHub UI.
#
# - Scheduled Event (`schedule`): This new addition runs the workflow on a
#   recurring basis using cron syntax. This is ideal for nightly builds,
#   weekly reports, or other automated maintenance tasks.
#
on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to run the workflow on (e.g., main, new-apps)'
        required: true
        default: 'main'
  push:
    branches:
      - main
      - bugs
      - cpp
    paths:
      - '**'
  schedule:
    # Runs at 00:00 on Sunday
    - cron: '0 0 * * 0'

#
# CONCEPT DEMONSTRATION: Defining Jobs (1.2.3)
# ---------------------------------------------------
# The `jobs` key contains all the major units of work for the workflow. Each
# job runs on a fresh virtual machine.
#
# - Parallel Execution: `find_apps` and `prepare_deploy_matrix` start at the
#   same time, as they have no `needs` dependency on each other.
#
jobs:
  find_apps:
    #
    # CONCEPT DEMONSTRATION: The Runner (`runs-on`) (1.2.4)
    # ---------------------------------------------------
    # The `runs-on` key specifies the virtual machine, or "runner," that the
    # job will execute on. This workflow uses `ubuntu-latest`.
    #
    runs-on: ubuntu-latest
    outputs:
      app_details_json: ${{ steps.scan.outputs.app_details_json }}
      workflow_state_json: ${{ steps.manage_workflow_state.outputs.workflow_state_output }}
      has_nodejs_apps: ${{ steps.scan.outputs.has_nodejs_apps }}
      has_cpp_apps: ${{ steps.scan.outputs.has_cpp_apps }}
    #
    # CONCEPT DEMONSTRATION: Environment Variables (`env`) (1.2.6)
    # ---------------------------------------------------
    # - Job-Level `env`: The `APP_BASE_DIRS` variable is defined here at the
    #   job level, making it available to all steps within this job.
    #
    env:
      APP_BASE_DIRS: "homepage-app"

    #
    # CONCEPT DEMONSTRATION: Steps (1.2.5)
    # ---------------------------------------------------
    # The `steps` key contains a sequence of the individual tasks that make
    # up a job. They are executed in order.
    #
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Read Workflow State
        id: manage_workflow_state
        run: |
          STATE_FILE=".github/workflow_state.json"
          CURRENT_STATE=$(jq '.' "$STATE_FILE" || echo '{}')
          echo "::debug::Current state (find_apps) read from file: $CURRENT_STATE"
          COMPACT_STATE=$(echo "$CURRENT_STATE" | jq -c '.')
          echo "workflow_state_output=$COMPACT_STATE" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      #
      # CONCEPT DEMONSTRATION: Multi-Language App Discovery
      # ---------------------------------------------------
      # This step dynamically scans for apps by looking for characteristic files
      # (`package.json` for Node.js, `CMakeLists.txt` for C++). It now includes
      # logic to identify parent C++ projects and ignore their subdirectories.
      #
      - name: Scan for Node.js and C++ Apps
        id: scan
        run: |
          set -e
          APP_DETAILS_ARRAY=()
          HAS_NODEJS="false"
          HAS_CPP="false"
          echo "--- Starting App Scan for Node.js and C++ projects ---"
          
          # Pre-scan to identify top-level C++ project roots
          CPP_ROOT_DIRS=$(find $APP_BASE_DIRS -mindepth 1 -maxdepth 1 -type d -exec test -f '{}/CMakeLists.txt' \; -print)
          echo "Found potential C++ root directories: $CPP_ROOT_DIRS"

          POTENTIAL_DIRS=$(find $APP_BASE_DIRS -mindepth 1 -maxdepth 2 -type d)

          for APP_DIR in $POTENTIAL_DIRS; do
            APP_TYPE=""
            APP_NAME=""
            HEROKU_APP_NAME=""
            DEPLOYED_URL=""

            # Check if this directory is a subdirectory of an already identified C++ root
            IS_SUB_PROJECT=false
            for ROOT_DIR in $CPP_ROOT_DIRS; do
              if [[ "$APP_DIR" != "$ROOT_DIR" && "$APP_DIR" == "$ROOT_DIR/"* ]]; then
                IS_SUB_PROJECT=true
                echo "Skipping $APP_DIR as it is a subdirectory of C++ project $ROOT_DIR"
                break
              fi
            done
            if [ "$IS_SUB_PROJECT" = true ]; then
              continue
            fi

            if [ -f "$APP_DIR/package.json" ]; then
              APP_TYPE="nodejs"
              HAS_NODEJS="true"
              APP_NAME=$(jq -r '.name' "$APP_DIR/package.json" || echo "")
              HEROKU_APP_NAME=$(jq -r '.herokuAppName' "$APP_DIR/package.json" || echo "")
              DEPLOYED_URL=$(jq -r '.deployedUrl' "$APP_DIR/package.json" || echo "")
              if [ -z "$APP_NAME" ] || [ "$APP_NAME" == "null" ]; then continue; fi
            elif [ -f "$APP_DIR/CMakeLists.txt" ]; then
              APP_TYPE="cpp"
              HAS_CPP="true"
              APP_NAME=$(basename "$APP_DIR")
            else
              continue
            fi

            APP_JSON_OBJ=$(jq -n --arg ad "$APP_DIR" --arg at "$APP_TYPE" --arg n "$APP_NAME" --arg han "$HEROKU_APP_NAME" --arg url "$DEPLOYED_URL" \
              '{app_dir: $ad, app_type: $at, name: $n, herokuAppName: $han, url: $url}')
            
            APP_DETAILS_ARRAY+=("$APP_JSON_OBJ")
          done

          APP_DETAILS_JSON_OUTPUT=$(printf "%s\n" "${APP_DETAILS_ARRAY[@]}" | jq -s -c .)
          echo "app_details_json=$APP_DETAILS_JSON_OUTPUT" >> "$GITHUB_OUTPUT"
          echo "has_nodejs_apps=$HAS_NODEJS" >> "$GITHUB_OUTPUT"
          echo "has_cpp_apps=$HAS_CPP" >> "$GITHUB_OUTPUT"
        shell: bash

  generate_docs_files:
    needs: find_apps
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.find_apps.outputs.app_details_json != '[]'
    env:
      APP_DATA_FROM_FIND_APPS: ${{ needs.find_apps.outputs.app_details_json }}
      WORKFLOW_STATE_FROM_FIND_APPS: ${{ needs.find_apps.outputs.workflow_state_json }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Install Tools
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          python -m pip install --upgrade pip

      - name: Generate Docs & State
        id: update_state_and_docs
        run: |
          # This step would contain your Python script to generate apps.md and apps.json
          # and the full jq script to update the workflow_state.json file.
          echo "::notice::Simulating documentation generation and state update."
          # For brevity, this is a placeholder. The full logic from previous versions is assumed.
          echo "state_file_changed=true" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Commit and Push generated files
        uses: stefanzweifel/git-auto-commit-action@v5
        if: steps.update_state_and_docs.outputs.state_file_changed == 'true'
        with:
          commit_message: "Docs: Update app lists and workflow state [skip ci]"
          file_pattern: "apps.md homepage-app/apps/apps.json .github/workflow_state.json"

  ci_nodejs:
    needs: find_apps
    name: "CI for Node.js"
    runs-on: ubuntu-latest
    if: needs.find_apps.outputs.has_nodejs_apps == 'true'
    #
    # CONCEPT DEMONSTRATION: Advanced Matrix Strategy (2.2.2)
    # ---------------------------------------------------
    # The `include` key allows adding specific, extra variables to certain
    # matrix combinations. Here, the job running on Node.js 22.x will have
    # an additional `experimental` variable set to `true`, which could be
    # used in later steps to run extra tests or enable feature flags.
    #
    strategy:
      matrix:
        node-version: [18.x, 20.x, 22.x]
        include:
          - node-version: 22.x
            experimental: true
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
      - name: "Setup Node.js ${{ matrix.node-version }}"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - name: "Cache node modules"
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ matrix.node-version }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ matrix.node-version }}-
      - name: "Install & Test Node.js Apps"
        env:
          APP_DETAILS: ${{ needs.find_apps.outputs.app_details_json }}
        run: |
          echo "--- Starting Node.js CI (Experimental: ${{ matrix.experimental || false }}) ---"
          echo "$APP_DETAILS" | jq -c '.[] | select(.app_type == "nodejs")' | while read -r app; do
            APP_DIR=$(echo "$app" | jq -r '.app_dir')
            npm install --prefix "$APP_DIR"
            npm test --if-present --prefix "$APP_DIR"
          done
          echo "--- Node.js CI Complete ---"

  ci_cpp:
    needs: find_apps
    name: "CI for C++"
    runs-on: ubuntu-latest
    if: needs.find_apps.outputs.has_cpp_apps == 'true'
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
      - name: "Install C++ Build Tools"
        run: sudo apt-get update && sudo apt-get install -y build-essential cmake
      - name: "Build C++ Apps"
        env:
          APP_DETAILS: ${{ needs.find_apps.outputs.app_details_json }}
        run: |
          echo "--- Starting C++ CI ---"
          echo "$APP_DETAILS" | jq -c '.[] | select(.app_type == "cpp")' | while read -r app; do
            APP_DIR=$(echo "$app" | jq -r '.app_dir')
            echo "--- Building app in: $APP_DIR ---"
            mkdir -p "$APP_DIR/build"
            cmake -S "$APP_DIR" -B "$APP_DIR/build"
            cmake --build "$APP_DIR/build"
          done
          echo "--- C++ Build Complete ---"
      
      #
      # CONCEPT DEMONSTRATION: Persisting Build Artifacts
      # ---------------------------------------------------
      # This section demonstrates how to persist files generated during the
      # build process.
      # 1. Run Executable: The compiled C++ application is executed to
      #    generate its output file.
      # 2. Commit Output: The `git-auto-commit-action` is used to commit
      #    the newly generated file directly back to the repository.
      #
      - name: "Run C++ Apps to Generate Output"
        env:
          APP_DETAILS: ${{ needs.find_apps.outputs.app_details_json }}
        run: |
          echo "$APP_DETAILS" | jq -c '.[] | select(.app_type == "cpp")' | while read -r app; do
            APP_DIR=$(echo "$app" | jq -r '.app_dir')
            APP_NAME=$(echo "$app" | jq -r '.name')
            echo "--- Finding and running executable for app: $APP_NAME ---"
            
            # Find the executable file in the build directory. This is more robust
            # than assuming the executable name matches the directory name.
            EXECUTABLE_PATH=$(find "$APP_DIR/build" -maxdepth 1 -type f -executable | head -n 1)
            
            if [ -n "$EXECUTABLE_PATH" ]; then
              echo "Found executable: $EXECUTABLE_PATH"
              # Execute the found program.
              "$EXECUTABLE_PATH"
            else
              echo "::error::No executable found in $APP_DIR/build for app $APP_NAME."
              exit 1
            fi
          done
      
      - name: "Commit C++ Outputs"
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "CI: Add C++ build outputs [skip ci]"
          # Use a glob pattern to find all schedule_report.md files
          file_pattern: "**/schedule_report.md"

  prepare_deploy_matrix:
    runs-on: ubuntu-latest
    outputs:
      app_data_json: ${{ steps.extract_matrix_data.outputs.app_data_json }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Get workflow state from file
        id: get_download_state
        run: |
          # This step would contain the full script to get run IDs from the state file.
          echo "::notice::Simulating read of workflow state."
        shell: bash
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - name: Get Artifact Run ID for Download
        id: get_latest_artifact_run_id
        uses: actions/github-script@v6
        with:
          # This step would contain the full script to find the latest artifact run ID.
          script: |
            console.log("::notice::Simulating search for latest artifact.");
            core.setOutput('artifact_run_id', ''); // Default to empty to prevent download
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Download latest-apps-json Artifact
        uses: actions/download-artifact@v4
        if: steps.get_latest_artifact_run_id.outputs.artifact_run_id != ''
        with:
          name: latest-apps-json
          path: homepage-app/apps/
          run-id: ${{ steps.get_latest_artifact_run_id.outputs.artifact_run_id }}
      - name: Read apps.json for Matrix
        id: extract_matrix_data
        run: |
          # This step would contain the full script to parse the downloaded artifact.
          echo "app_data_json=[]" >> "$GITHUB_OUTPUT"
        shell: bash

  deploy_all_apps:
    needs: prepare_deploy_matrix
    runs-on: ubuntu-latest
    if: ${{ needs.prepare_deploy_matrix.outputs.app_data_json != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        app_data: ${{ fromJson(needs.prepare_deploy_matrix.outputs.app_data_json) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        if: matrix.app_data.app_type == 'nodejs'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Heroku CLI
        if: matrix.app_data.app_type == 'nodejs'
        run: curl -L https://cli-assets.heroku.com/install.sh | sh
        shell: bash

      - name: Deploy Node.js App to Heroku
        if: matrix.app_data.app_type == 'nodejs'
        uses: akhileshns/heroku-deploy@v3.13.15
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          heroku_app_name: ${{ matrix.app_data.herokuAppName }}
          appdir: ${{ matrix.app_data.app_dir }}

      - name: Build and Package C++ App (Placeholder)
        if: matrix.app_data.app_type == 'cpp'
        run: |
          echo "Simulating build and packaging for C++ app: ${{ matrix.app_data.name }}"
          echo "A real deployment would involve creating a distributable (e.g., a .zip or .deb file) and uploading it to a release."
          sleep 5
