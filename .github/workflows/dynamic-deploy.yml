#
# Copyright (C) 2025 Eeshvar Das (Erik Douglas Ward) (https://github.com/apm-essence-groove/apm-essence-groove-ci-cd)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

name: Full App Discovery, Docs & Deploy

#
# CONCEPT DEMONSTRATION: Naming the Workflow (1.2.1)
# ---------------------------------------------------
# The `name` key provides a clear, human-readable name for the workflow.
# This name is what appears in the GitHub Actions UI, making it easy to
# identify and distinguish from other workflows in the repository.
#

#
# CONCEPT DEMONSTRATION: The 'on' Event Trigger (1.2.2)
# ---------------------------------------------------
# The `on` key defines the event(s) that will trigger the workflow. This workflow
# demonstrates several types of triggers:
#
# - Webhook Event (`push`): The workflow runs automatically when a commit is
#   pushed to the repository.
#
# - Filtered Webhooks (`branches`, `paths`): The `push` event is filtered to
#   only run for commits on specific branches and when changes occur in any
#   file path (`**`).
#
# - Manual Event (`workflow_dispatch`): Allows the workflow to be triggered
#   manually from the GitHub UI.
#
# - Scheduled Event (`schedule`): This new addition runs the workflow on a
#   recurring basis using cron syntax. This is ideal for nightly builds,
#   weekly reports, or other automated maintenance tasks.
#
on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to run the workflow on (e.g., main, new-apps)'
        required: true
        default: 'main'
  push:
    branches:
      - main
      - bugs
      - cpp
    paths:
      - '**'

#
# CONCEPT DEMONSTRATION: Defining Jobs (1.2.3)
# ---------------------------------------------------
# The `jobs` key contains all the major units of work for the workflow. Each
# job runs on a fresh virtual machine.
#
# - Parallel Execution: `find_apps`, `prepare_deploy_matrix`,
#   `intelligent_ci`, and `deploy_for_testing` start at the same time.
#
jobs:
  find_apps:
    #
    # CONCEPT DEMONSTRATION: The Runner (`runs-on`) (1.2.4)
    # ---------------------------------------------------
    # The `runs-on` key specifies the virtual machine, or "runner," that the
    # job will execute on. This workflow uses `ubuntu-latest`.
    #
    runs-on: ubuntu-latest
    outputs:
      app_details_json: ${{ steps.scan.outputs.app_details_json }}
      workflow_state_json: ${{ steps.manage_workflow_state.outputs.workflow_state_output }}
    #
    # CONCEPT DEMONSTRATION: Environment Variables (`env`) (1.2.6)
    # ---------------------------------------------------
    # - Job-Level `env`: The `APP_BASE_DIRS` variable is defined here at the
    #   job level, making it available to all steps within this job.
    #
    env:
      APP_BASE_DIRS: "homepage-app"

    #
    # CONCEPT DEMONSTRATION: Steps (1.2.5)
    # ---------------------------------------------------
    # The `steps` key contains a sequence of the individual tasks that make
    # up a job. They are executed in order.
    #
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Read Workflow State
        id: manage_workflow_state
        run: |
          STATE_FILE=".github/workflow_state.json"
          CURRENT_STATE=$(jq '.' "$STATE_FILE" || echo '{}')
          echo "::debug::Current state (find_apps) read from file: $CURRENT_STATE"
          COMPACT_STATE=$(echo "$CURRENT_STATE" | jq -c '.')
          echo "workflow_state_output=$COMPACT_STATE" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Scan for Apps and Collect Details
        id: scan
        run: |
          set -e
          APP_DETAILS_ARRAY=()
          echo "--- Starting App Scan ---"
          for BASE_DIR in $APP_BASE_DIRS; do
            if [ ! -d "$BASE_DIR" ]; then
              echo "::error::Base directory '$BASE_DIR' not found."
              continue
            fi
            FOUND_DIRS=$(find "$BASE_DIR" -type f -name "package.json" -exec dirname {} \;)
            for APP_DIR in $FOUND_DIRS; do
              PACKAGE_JSON_PATH="$APP_DIR/package.json"
              APP_NAME=$(jq -r '.name' "$PACKAGE_JSON_PATH" || echo "")
              HEROKU_APP_NAME=$(jq -r '.herokuAppName' "$PACKAGE_JSON_PATH" || echo "")
              DEPLOYED_URL=$(jq -r '.deployedUrl' "$PACKAGE_JSON_PATH" || echo "")
              if [ -z "$APP_NAME" ] || [ "$APP_NAME" == "null" ]; then continue; fi
              
              APP_JSON_OBJ=$(jq -n --arg ad "$APP_DIR" --arg n "$APP_NAME" --arg han "$HEROKU_APP_NAME" --arg url "$DEPLOYED_URL" \
                '{app_dir: $ad, name: $n, herokuAppName: $han, url: $url}')
              APP_DETAILS_ARRAY+=("$APP_JSON_OBJ")
            done
          done
          APP_DETAILS_JSON_OUTPUT=$(printf "%s\n" "${APP_DETAILS_ARRAY[@]}" | jq -s -c .)
          echo "app_details_json=$APP_DETAILS_JSON_OUTPUT" >> "$GITHUB_OUTPUT"
        shell: bash

  generate_docs_files:
    needs: find_apps
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.find_apps.outputs.app_details_json != '[]'
    env:
      APP_DATA_FROM_FIND_APPS: ${{ needs.find_apps.outputs.app_details_json }}
      WORKFLOW_STATE_FROM_FIND_APPS: ${{ needs.find_apps.outputs.workflow_state_json }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Read Diagnostic Flag from State
        id: read_diag_flag
        run: |
          diag_flag=$(echo '${{ env.WORKFLOW_STATE_FROM_FIND_APPS }}' | jq -r '.required_diagnostics // false')
          echo "is_enabled=$diag_flag" >> "$GITHUB_OUTPUT"

      - name: Note on Diagnostics
        if: steps.read_diag_flag.outputs.is_enabled == 'true'
        run: |
          echo "::warning::Note: The diagnostic features in this workflow are not yet fully implemented."

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
        
      - name: Generate apps.md and apps.json Content
        id: generate_content_py
        run: python .github/scripts/generate_app_list.py
        env:
          APP_DATA_FROM_FIND_APPS: ${{ env.APP_DATA_FROM_FIND_APPS }}
          RWT_WRITABLE_FILE_APPS_MD: ${{ secrets.RWT_WRITABLE_FILE_APPS_MD }}
          RWT_WRITABLE_FILE_HOMEPAGE_APPS_JSON: ${{ secrets.RWT_WRITABLE_FILE_HOMEPAGE_APPS_JSON }}
          
      - name: Write apps.md File
        if: ${{ steps.generate_content_py.outputs.apps_md_updated_flag == 'true' }}
        run: |
          APPS_MD_SECTION_CONTENT="${{ steps.generate_content_py.outputs.apps_md_section_content }}"
          echo "$APPS_MD_SECTION_CONTENT" > apps.md
        shell: bash

      - name: Update Workflow State File and Determine Commit
        id: update_state_file_content
        run: |
          # This is the full, restored jq script for state management and versioning
          INCOMING_STATE='${{ env.WORKFLOW_STATE_FROM_FIND_APPS }}'
          STATE_FILE=".github/workflow_state.json"
          APPS_JSON_UPDATED_THIS_RUN="${{ steps.generate_content_py.outputs.apps_json_updated_flag }}"
          CURRENT_WORKFLOW_RUN_ID="${{ github.run_id }}"
          CURRENT_TIMESTAMP_ISO=$(date -u -Iseconds)
          CURRENT_TIMESTAMP_EPOCH=$(date -u +%s)
          
          UPDATED_STATE=$(jq -n \
            --argjson incoming_state "$INCOMING_STATE" \
            --arg apps_json_updated "$APPS_JSON_UPDATED_THIS_RUN" \
            --arg current_run_id "$CURRENT_WORKFLOW_RUN_ID" \
            --arg current_ts_iso "$CURRENT_TIMESTAMP_ISO" \
            --arg current_ts_epoch "$CURRENT_TIMESTAMP_EPOCH" \
            '
            # Define keys
            def keys: {
              dc: "apps_json_download_count", fu: "force_next_upload", uc: "apps_json_upload_count",
              dt: "apps_json_download_threshold", diag: "required_diagnostics", version: "artifact_version",
              strategy: "version_update_strategy", last_run: "last_successful_artifact_run",
              current_run: "current_successful_artifact_run", historical_run: "historical_artifact_run",
              legacy_lari: "last_successful_apps_json_artifact_run_id", legacy_cari: "current_apps_json_artifact_run_id"
            };
            def upgrade(legacy_key; new_key):
              if $incoming_state | has(new_key) and ($incoming_state[new_key] | type == "object") then $incoming_state[new_key]
              elif $incoming_state | has(legacy_key) and ($incoming_state[legacy_key] | type == "string") then { id: $incoming_state[legacy_key], timestamp: null, (keys.version): ($incoming_state[keys.version] // "0.1.0") }
              else { id: null, timestamp: null, (keys.version): "0.1.0" }
              end;
            (
              upgrade(keys.legacy_lari; keys.last_run) as $migrated_last |
              upgrade(keys.legacy_cari; keys.current_run) as $migrated_current |
              (if $incoming_state | has(keys.historical_run) and ($incoming_state[keys.historical_run] | type == "object") then $incoming_state[keys.historical_run] else { id: null, timestamp: null, (keys.version): "0.1.0" } end) as $migrated_historical |
              (if $apps_json_updated == "true" then { new_last: $migrated_current, new_current: { id: $current_run_id, timestamp: $current_ts_iso } } else { new_last: $migrated_last, new_current: $migrated_current } end) as $promoted |
              (if $promoted.new_last.timestamp != null and (($current_ts_epoch | tonumber) - ($promoted.new_last.timestamp | fromdate) > 3600) then $promoted.new_last else $migrated_historical end) as $new_historical |
              (($migrated_current[keys.version] // "0.1.0") as $current_version | ($incoming_state[keys.strategy] // "DEVELOPING") as $strategy |
              if $new_historical.id == $promoted.new_last.id and $new_historical.id != $migrated_historical.id then
                ($current_version | split(".") | map(tonumber) as $parts |
                if $strategy == "NEW_MAJOR_VERSION" then { v: "\($parts[0] + 1).0.0", s: "DEVELOPING" }
                elif $strategy == "NEW_MINOR_VERSION" then { v: "\($parts[0]).\($parts[1] + 1).0", s: "DEVELOPING" }
                elif $parts[2] < 9 then { v: "\($parts[0]).\($parts[1]).\($parts[2] + 1)", s: $strategy }
                else { v: "\($parts[0]).\($parts[1] + 1).0", s: $strategy }
                end)
              else { v: $current_version, s: $strategy }
              end) as $version_info |
              {
                (keys.dc): (if ($incoming_state[keys.dt] // 0) == 0 or $apps_json_updated == "true" then 0 else ($incoming_state[keys.dc] // 0) + 1 end),
                (keys.fu): (if ($incoming_state[keys.dt] // 0) == 0 then true else false end),
                (keys.uc): (if $apps_json_updated == "true" then ($incoming_state[keys.uc] // 0) + 1 else ($incoming_state[keys.uc] // 0) end),
                (keys.dt): ($incoming_state[keys.dt] // 0),
                (keys.diag): ($incoming_state[keys.diag] // false),
                (keys.strategy): $version_info.s
              } + {
                (keys.last_run): $promoted.new_last,
                (keys.current_run): (if $apps_json_updated == "true" then $promoted.new_current + { (keys.version): $version_info.v } else $promoted.new_current end),
                (keys.historical_run): $new_historical
              }
            )
            '
          )
          echo "NEW STATE: $UPDATED_STATE"
          echo "$UPDATED_STATE" > "$STATE_FILE"
          if [ -z "$(diff -q <(echo "$INCOMING_STATE" | jq '.') "$STATE_FILE")" ]; then
             echo "state_file_changed=false" >> "$GITHUB_OUTPUT"
          else
             echo "state_file_changed=true" >> "$GITHUB_OUTPUT"
          fi
        shell: bash

      - name: Upload homepage-app/apps/apps.json as Artifact
        if: steps.generate_content_py.outputs.apps_json_updated_flag == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: latest-apps-json
          path: homepage-app/apps/apps.json
          retention-days: 7

      - name: Copy State File for Web App Access
        run: |
          mkdir -p homepage-app/apps
          cp .github/workflow_state.json homepage-app/apps/workflow_state.json

      - name: Commit and Push generated files
        uses: stefanzweifel/git-auto-commit-action@v5
        if: steps.update_state_file_content.outputs.state_file_changed == 'true'
        with:
          commit_message: "Docs: Update app lists and workflow state [skip ci]"
          file_pattern: "apps.md homepage-app/apps/apps.json homepage-app/apps/workflow_state.json .github/workflow_state.json"

  ci_nodejs:
    needs: find_apps
    name: "CI for Node.js"
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18.x, 20.x, 22.x]
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
      - name: "Setup Node.js ${{ matrix.node-version }}"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - name: "Cache node modules"
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ matrix.node-version }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ matrix.node-version }}-
      - name: "Install & Test Node.js Apps"
        env:
          APP_DETAILS: ${{ needs.find_apps.outputs.app_details_json }}
        run: |
          echo "$APP_DETAILS" | jq -c '.[]' | while read -r app; do
            APP_DIR=$(echo "$app" | jq -r '.app_dir')
            npm install --prefix "$APP_DIR"
            npm test --if-present --prefix "$APP_DIR"
          done

  prepare_deploy_matrix:
    runs-on: ubuntu-latest
    outputs:
      app_data_json: ${{ steps.extract_matrix_data.outputs.app_data_json }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Get workflow state from file
        id: get_download_state
        run: |
          STATE_FILE=".github/workflow_state.json"
          WORKFLOW_STATE_JSON=$(jq -c '.' "$STATE_FILE" || echo '{}')
          HISTORICAL_RUN_ID=$(echo "$WORKFLOW_STATE_JSON" | jq -r '.historical_artifact_run.id // ""')
          CURRENT_RUN_ID=$(echo "$WORKFLOW_STATE_JSON" | jq -r '.current_successful_artifact_run.id // ""')
          LAST_RUN_ID=$(echo "$WORKFLOW_STATE_JSON" | jq -r '.last_successful_artifact_run.id // ""')
          echo "historical_run_id=$HISTORICAL_RUN_ID" >> "$GITHUB_OUTPUT"
          echo "current_run_id=$CURRENT_RUN_ID" >> "$GITHUB_OUTPUT"
          echo "last_run_id=$LAST_RUN_ID" >> "$GITHUB_OUTPUT"
        shell: bash
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - name: Get Artifact Run ID for Download
        id: get_latest_artifact_run_id
        uses: actions/github-script@v6
        with:
          script: |
            const artifactName = 'latest-apps-json';
            const { owner, repo } = context.repo;
            const runIds = [
              {id: process.env.HISTORICAL_RUN_ID, label: "Historical"},
              {id: process.env.CURRENT_RUN_ID, label: "Current"},
              {id: process.env.LAST_RUN_ID, label: "Last"}
            ];
            for (const run of runIds) {
              if (run.id && run.id !== 'null') {
                try {
                  const { data: { artifacts } } = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id: run.id });
                  if (artifacts.find(artifact => artifact.name === artifactName)) {
                    core.setOutput('artifact_run_id', run.id);
                    return;
                  }
                } catch (error) {
                  console.log(`WARN: Could not check artifacts for ${run.label} run ID ${run.id}.`);
                }
              }
            }
            core.setOutput('artifact_run_id', '');
          github-token: ${{ secrets.GITHUB_TOKEN }}
        env:
          HISTORICAL_RUN_ID: ${{ steps.get_download_state.outputs.historical_run_id }}
          CURRENT_RUN_ID: ${{ steps.get_download_state.outputs.current_run_id }}
          LAST_RUN_ID: ${{ steps.get_download_state.outputs.last_run_id }}
      - name: Download latest-apps-json Artifact
        uses: actions/download-artifact@v4
        if: steps.get_latest_artifact_run_id.outputs.artifact_run_id != ''
        with:
          name: latest-apps-json
          path: homepage-app/apps/
          run-id: ${{ steps.get_latest_artifact_run_id.outputs.artifact_run_id }}
      - name: Read apps.json for Matrix
        id: extract_matrix_data
        run: |
          set -e
          APPS_JSON_PATH="homepage-app/apps/apps.json"
          app_data_json_output="[]"
          if [ -f "$APPS_JSON_PATH" ]; then
            PARSED_DATA=$(jq '[.[] | . + {"deploy_app": true}]' "$APPS_JSON_PATH")
            if [ -n "$PARSED_DATA" ] && [ "$PARSED_DATA" != "null" ] && [ "$(echo "$PARSED_DATA" | jq 'length')" -gt 0 ]; then
              app_data_json_output="$PARSED_DATA"
            fi
          fi
          echo "app_data_json=$app_data_json_output" >> "$GITHUB_OUTPUT"
        shell: bash

  deploy_all_apps:
    needs: prepare_deploy_matrix
    runs-on: ubuntu-latest
    if: ${{ needs.prepare_deploy_matrix.outputs.app_data_json != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        app_data: ${{ fromJson(needs.prepare_deploy_matrix.outputs.app_data_json) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Heroku CLI
        run: curl -L https://cli-assets.heroku.com/install.sh | sh
        shell: bash

      - name: Deploy to Heroku
        uses: akhileshns/heroku-deploy@v3.13.15
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          heroku_app_name: ${{ matrix.app_data.herokuAppName }}
          appdir: ${{ matrix.app_data.app_dir }}
