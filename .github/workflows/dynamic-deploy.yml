#
# Copyright (C) 2025 Eeshvar Das (Erik Douglas Ward) (https://github.com/apm-essence-groove/apm-essence-groove-ci-cd)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

name: Full App Discovery, Docs & Deploy

#
# CONCEPT DEMONSTRATION: Naming the Workflow (1.2.1)
# ---------------------------------------------------
# The `name` key provides a clear, human-readable name for the workflow.
# This name is what appears in the GitHub Actions UI, making it easy to
# identify and distinguish from other workflows in the repository.
#

#
# CONCEPT DEMONSTRATION: The 'on' Event Trigger (1.2.2)
# ---------------------------------------------------
# The `on` key defines the event(s) that will trigger the workflow. This workflow
# demonstrates several types of triggers:
#
# - Webhook Event (`push`): The workflow runs automatically when a commit is
#   pushed to the repository.
#
# - Filtered Webhooks (`branches`, `paths`): The `push` event is filtered to
#   only run for commits on specific branches (`main`, `bugs`)
#   and when changes occur in any file path (`**`). This prevents the workflow
#   from running unnecessarily on other branches.
#
# - Manual Event (`workflow_dispatch`): This allows the workflow to be
#   triggered manually from the GitHub UI, providing an `input` for the user
#   to specify which branch to run against.
#
# Other common triggers not used here include `schedule` for running at
# specific times (e.g., nightly builds) and `pull_request` for running
# checks when a pull request is opened or updated.
#
on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to run the workflow on (e.g., main, new-apps)'
        required: true
        default: 'main'
  push:
    branches:
      - main
      - bugs
      - cpp
    paths:
      - '**'

#
# CONCEPT DEMONSTRATION: Defining Jobs (1.2.3)
# ---------------------------------------------------
# The `jobs` key contains all the major units of work for the workflow. Each
# key under `jobs` (e.g., `find_apps`, `prepare_deploy_matrix`) is a separate
# job that runs on a fresh virtual machine.
#
# - Parallel Execution: By default, all jobs without a `needs` dependency
#   run in parallel. In this workflow, `find_apps` and `prepare_deploy_matrix`
#   start at the same time. Other jobs depend on their outputs.
#
# - Workflow/Job Relationship: The workflow itself is the overall process
#   defined by this file. The jobs are the individual, executable components
#   that carry out the steps of that process.
#
jobs:
  find_apps:
    #
    # CONCEPT DEMONSTRATION: The Runner (`runs-on`) (1.2.4)
    # ---------------------------------------------------
    # The `runs-on` key specifies the type of virtual machine, or "runner,"
    # that the job will execute on. This workflow uses `ubuntu-latest`.
    #
    runs-on: ubuntu-latest
    outputs:
      app_details_json: ${{ steps.scan.outputs.app_details_json }}
      workflow_state_json: ${{ steps.manage_workflow_state.outputs.workflow_state_output }}
      has_nodejs_apps: ${{ steps.scan.outputs.has_nodejs_apps }}
      has_cpp_apps: ${{ steps.scan.outputs.has_cpp_apps }}
    #
    # CONCEPT DEMONSTRATION: Environment Variables (`env`) (1.2.6)
    # ---------------------------------------------------
    # - Job-Level `env`: The `APP_BASE_DIRS` variable is defined here at the
    #   job level, making it available to all steps within the `find_apps` job.
    #
    env:
      APP_BASE_DIRS: "homepage-app"

    #
    # CONCEPT DEMONSTRATION: Steps (1.2.5)
    # ---------------------------------------------------
    # The `steps` key contains a sequence of the individual tasks that make
    # up a job. They are executed in order.
    #
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Read Workflow State
        id: manage_workflow_state
        run: |
          STATE_FILE=".github/workflow_state.json"
          CURRENT_STATE=$(jq '.' "$STATE_FILE" || echo '{}')
          echo "::debug::Current state (find_apps) read from file: $CURRENT_STATE"
          COMPACT_STATE=$(echo "$CURRENT_STATE" | jq -c '.')
          echo "workflow_state_output=$COMPACT_STATE" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      #
      # CONCEPT DEMONSTRATION: Multi-Language App Discovery
      # ---------------------------------------------------
      # This step dynamically scans the repository for applications of different
      # types by looking for characteristic files (`package.json` for Node.js,
      # `CMakeLists.txt` for C++). It tags each app with a type, allowing
      # subsequent jobs to run conditionally based on the projects found.
      #
      - name: Scan for Node.js and C++ Apps
        id: scan
        run: |
          set -e
          APP_DETAILS_ARRAY=()
          HAS_NODEJS="false"
          HAS_CPP="false"
          echo "--- Starting App Scan for Node.js and C++ projects ---"
          
          # Find all potential app directories
          POTENTIAL_DIRS=$(find $APP_BASE_DIRS -mindepth 1 -maxdepth 2 -type d)

          for APP_DIR in $POTENTIAL_DIRS; do
            APP_TYPE=""
            APP_NAME=""
            HEROKU_APP_NAME=""
            DEPLOYED_URL=""

            # Check for Node.js project
            if [ -f "$APP_DIR/package.json" ]; then
              echo "--- Processing Node.js app: $APP_DIR ---"
              APP_TYPE="nodejs"
              HAS_NODEJS="true"
              APP_NAME=$(jq -r '.name' "$APP_DIR/package.json" || echo "")
              HEROKU_APP_NAME=$(jq -r '.herokuAppName' "$APP_DIR/package.json" || echo "")
              DEPLOYED_URL=$(jq -r '.deployedUrl' "$APP_DIR/package.json" || echo "")
              if [ -z "$APP_NAME" ] || [ "$APP_NAME" == "null" ]; then
                echo "::warning::'name' missing in ${APP_DIR}/package.json. Skipping."
                continue
              fi
            # Check for C++ project
            elif [ -f "$APP_DIR/CMakeLists.txt" ]; then
              echo "--- Processing C++ app: $APP_DIR ---"
              APP_TYPE="cpp"
              HAS_CPP="true"
              APP_NAME=$(basename "$APP_DIR") # Use folder name for C++ apps
            else
              continue # Not a recognized app type
            fi

            APP_JSON_OBJ=$(jq -n \
              --arg app_dir "$APP_DIR" \
              --arg app_type "$APP_TYPE" \
              --arg name "$APP_NAME" \
              --arg herokuAppName "$HEROKU_APP_NAME" \
              --arg url "$DEPLOYED_URL" \
              '{app_dir: $app_dir, app_type: $app_type, name: $name, herokuAppName: $herokuAppName, url: $url}')
            
            APP_DETAILS_ARRAY+=("$APP_JSON_OBJ")
          done

          echo "--- App Scan Summary ---"
          if [ ${#APP_DETAILS_ARRAY[@]} -eq 0 ]; then
            echo "No valid applications found."
            APP_DETAILS_JSON_OUTPUT="[]"
          else
            APP_DETAILS_JSON_OUTPUT=$(printf "%s\n" "${APP_DETAILS_ARRAY[@]}" | jq -s -c .)
          fi
          
          echo "Final app_details_json output: $APP_DETAILS_JSON_OUTPUT"
          echo "app_details_json=$APP_DETAILS_JSON_OUTPUT" >> "$GITHUB_OUTPUT"
          echo "has_nodejs_apps=$HAS_NODEJS" >> "$GITHUB_OUTPUT"
          echo "has_cpp_apps=$HAS_CPP" >> "$GITHUB_OUTPUT"
        shell: bash

  generate_docs_files:
    needs: find_apps
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.find_apps.outputs.app_details_json != '[]'
    env:
      APP_DATA_FROM_FIND_APPS: ${{ needs.find_apps.outputs.app_details_json }}
      WORKFLOW_STATE_FROM_FIND_APPS: ${{ needs.find_apps.outputs.workflow_state_json }}

    steps:
      # Steps for generating docs, updating state, and committing...
      # This job remains largely the same but now operates on data that includes C++ apps.
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Update State, Version, and Commit
        id: update_state_file_content
        run: |
          # The full jq script for state and version management goes here...
          # This script is now simplified as the build_profile is removed.
          echo "State update logic would run here."
          # For brevity, this is a placeholder. The full script from previous versions is assumed.
        shell: bash

  ci_nodejs:
    needs: find_apps
    name: "CI for Node.js"
    runs-on: ubuntu-latest
    if: needs.find_apps.outputs.has_nodejs_apps == 'true'
    strategy:
      matrix:
        node-version: [18.x, 20.x, 22.x]
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
      - name: "Setup Node.js ${{ matrix.node-version }}"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - name: "Cache node modules"
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ matrix.node-version }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ matrix.node-version }}-
      - name: "Install & Test Node.js Apps"
        env:
          APP_DETAILS: ${{ needs.find_apps.outputs.app_details_json }}
        run: |
          echo "--- Starting Node.js CI ---"
          echo "$APP_DETAILS" | jq -c '.[] | select(.app_type == "nodejs")' | while read -r app; do
            APP_DIR=$(echo "$app" | jq -r '.app_dir')
            echo "--- Testing app in: $APP_DIR ---"
            npm install --prefix "$APP_DIR"
            npm test --if-present --prefix "$APP_DIR"
          done
          echo "--- Node.js CI Complete ---"

  ci_cpp:
    needs: find_apps
    name: "CI for C++"
    runs-on: ubuntu-latest
    if: needs.find_apps.outputs.has_cpp_apps == 'true'
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
      - name: "Install C++ Build Tools"
        run: sudo apt-get update && sudo apt-get install -y build-essential cmake
      - name: "Build C++ Apps"
        env:
          APP_DETAILS: ${{ needs.find_apps.outputs.app_details_json }}
        run: |
          echo "--- Starting C++ CI ---"
          echo "$APP_DETAILS" | jq -c '.[] | select(.app_type == "cpp")' | while read -r app; do
            APP_DIR=$(echo "$app" | jq -r '.app_dir')
            echo "--- Building app in: $APP_DIR ---"
            mkdir -p "$APP_DIR/build"
            cmake -S "$APP_DIR" -B "$APP_DIR/build"
            cmake --build "$APP_DIR/build"
          done
          echo "--- C++ CI Complete ---"

  prepare_deploy_matrix:
    runs-on: ubuntu-latest
    outputs:
      app_data_json: ${{ steps.extract_matrix_data.outputs.app_data_json }}
    steps:
      # This job remains the same, but the artifact it downloads now contains app_type
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Get workflow state from file
        id: get_download_state
        run: |
          # ... (script to get run IDs from state file)
        shell: bash
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - name: Get Artifact Run ID for Download
        id: get_latest_artifact_run_id
        uses: actions/github-script@v6
        with:
          # ... (script to find latest artifact)
          github-token: ${{ secrets.GITHUB_TOKEN }}
        env:
          # ... (env vars for run IDs)
      - name: Download latest-apps-json Artifact
        uses: actions/download-artifact@v4
        # ... (with block)
      - name: Read apps.json for Matrix
        id: extract_matrix_data
        run: |
          set -e
          APPS_JSON_PATH="homepage-app/apps/apps.json"
          app_data_json_output="[{\"dummy_run\":true,\"deploy_app\":false}]"
          if [ -f "$APPS_JSON_PATH" ]; then
            # Pass the full app object, including app_type
            PARSED_DATA=$(jq '[.apps[] | select(has("app_dir")) | . + {"deploy_app": true}]' "$APPS_JSON_PATH")
            if [ -n "$PARSED_DATA" ] && [ "$PARSED_DATA" != "null" ] && [ "$(echo "$PARSED_DATA" | jq 'length')" -gt 0 ]; then
              app_data_json_output="$PARSED_DATA"
            fi
          fi
          echo "app_data_json<<EOF" >> "$GITHUB_OUTPUT"
          echo "$app_data_json_output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
        shell: bash

  deploy_all_apps:
    needs: prepare_deploy_matrix
    runs-on: ubuntu-latest
    if: ${{ needs.prepare_deploy_matrix.outputs.app_data_json != '[{"dummy_run":true,"deploy_app":false}]' }}
    strategy:
      fail-fast: false
      matrix:
        app_data: ${{ fromJson(needs.prepare_deploy_matrix.outputs.app_data_json) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        if: matrix.app_data.app_type == 'nodejs'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Heroku CLI
        if: matrix.app_data.app_type == 'nodejs'
        run: curl -L https://cli-assets.heroku.com/install.sh | sh
        shell: bash

      - name: Deploy Node.js App to Heroku
        if: matrix.app_data.app_type == 'nodejs'
        uses: akhileshns/heroku-deploy@v3.13.15
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          heroku_app_name: ${{ matrix.app_data.herokuAppName }}
          appdir: ${{ matrix.app_data.app_dir }}

      - name: Build and Package C++ App (Placeholder)
        if: matrix.app_data.app_type == 'cpp'
        run: |
          echo "Simulating build and packaging for C++ app: ${{ matrix.app_data.name }}"
          echo "A real deployment would involve creating a distributable (e.g., a .zip or .deb file) and uploading it to a release."
          sleep 5
